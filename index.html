<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <title>DATA_DECAY_V12_CORRUPTION</title>
    <style>
        :root {
            --bg: #050505;
            --main: #ffffff; 
            --text-font: 'Courier New', Courier, monospace;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg);
            overflow: hidden;
            font-family: var(--text-font);
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
        }

        /* Invert Mode Styles */
        body.inverted {
            filter: invert(1);
        }
        /* Keep UI readable in invert mode by re-inverting it */
        body.inverted #ui-container {
            filter: invert(1);
        }
        /* Keep canvas raw in invert mode? No, we want canvas inverted too. 
           But we need the Video to look correct if Live BG is on.
           Actually, simpler to handle Invert in Canvas logic.
        */

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px 20px;
            box-sizing: border-box;
        }

        #ui-container.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .controls-top {
            display: flex;
            flex-direction: column;
            gap: 15px; /* Tighter gap */
            margin-top: 10px;
        }

        #custom-text {
            background: rgba(0,0,0,0.6);
            border: 1px solid var(--main);
            color: var(--main);
            font-family: var(--text-font);
            font-size: 16px; 
            padding: 10px;
            text-transform: uppercase;
            width: 100%;
            box-sizing: border-box;
            outline: none;
            text-align: center;
        }
        
        #custom-text::placeholder { color: rgba(255,255,255,0.5); }

        .slider-row {
            display: flex;
            align-items: center;
            width: 100%;
            color: var(--main);
            text-shadow: 0px 1px 3px rgba(0,0,0,0.8);
            font-weight: bold;
            font-size: 12px;
        }

        .label { width: 70px; letter-spacing: 1px; }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            height: 20px;
            cursor: pointer;
        }
        
        input[type=range]:focus { outline: none; }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: var(--main);
            box-shadow: 0px 1px 2px rgba(0,0,0,0.8);
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: var(--main);
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0px 1px 5px rgba(0,0,0,0.5);
        }

        .controls-bottom {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .button-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 8px;
        }
        
        .button-row-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        button {
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--main);
            font-family: var(--text-font);
            font-weight: bold;
            font-size: 11px; 
            text-transform: uppercase;
            cursor: pointer;
            text-shadow: 0px 1px 2px rgba(0,0,0,1);
            padding: 12px 0;
            white-space: nowrap;
        }
        
        button:active { background: var(--main); color: #000; }
        
        /* Highlight active invert button */
        button.active-state {
            background: var(--main);
            color: #000;
        }

        #start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            text-align: center;
        }
        
        #start-btn { 
            border: 1px solid var(--main); 
            padding: 15px 30px; 
            font-size: 16px;
            background: rgba(0,0,0,0.8);
            color: var(--main);
        }

        .version {
            margin-top: 10px;
            font-size: 10px;
            color: var(--main);
            opacity: 0.7;
        }

        .scanline {
            width: 100%;
            height: 100%;
            z-index: 5;
            background: linear-gradient(0deg, rgba(0,0,0,0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06));
            background-size: 100% 2px, 3px 100%;
            position: absolute;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="scanline"></div>
    
    <div id="start-screen">
        <button id="start-btn">INITIALIZE</button>
        <div class="version">V12.0_CORRUPTION</div>
    </div>

    <div id="ui-container">
        
        <div class="controls-top">
            <input type="text" id="custom-text" placeholder="[ ENTER DATA INJECTION ]" maxlength="20">
            
            <div class="slider-row">
                <span class="label">GRID</span>
                <input type="range" id="input-grid" min="6" max="40" value="12">
            </div>
            <div class="slider-row">
                <span class="label">FPS</span>
                <input type="range" id="input-fps" min="1" max="60" value="30">
            </div>
            <div class="slider-row">
                <span class="label">DECAY</span>
                <input type="range" id="input-fade" min="0" max="100" value="30">
            </div>
            <div class="slider-row">
                <span class="label">FX</span>
                <input type="range" id="input-fx" min="0" max="100" value="0">
            </div>
        </div>

        <div class="controls-bottom">
            <div class="button-row">
                <button id="flip-btn">FLIP</button>
                <button id="mode-btn">MOD: GRID</button>
                <button id="color-btn">CLR: WHT</button>
                <button id="inv-btn">INV: OFF</button>
            </div>
            <div class="button-row-2">
                <button id="freeze-btn">FRZ</button>
                <button id="snap-btn">SNAP</button>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>
    <video id="video" playsinline style="display:none"></video>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('video');
        const startBtn = document.getElementById('start-btn');
        const uiContainer = document.getElementById('ui-container');
        
        const inputGrid = document.getElementById('input-grid');
        const inputFps = document.getElementById('input-fps');
        const inputFade = document.getElementById('input-fade');
        const inputFx = document.getElementById('input-fx'); // Replaced Contrast with FX
        const customTextInput = document.getElementById('custom-text');
        
        const flipBtn = document.getElementById('flip-btn');
        const modeBtn = document.getElementById('mode-btn');
        const colorBtn = document.getElementById('color-btn');
        const invBtn = document.getElementById('inv-btn'); // Replaced BG button with Invert
        const freezeBtn = document.getElementById('freeze-btn');
        const snapBtn = document.getElementById('snap-btn');

        let config = {
            gridSize: 12,
            targetFPS: 30,
            fadeAlpha: 0.3, 
            fxLevel: 0, // 0 to 100
            colorMode: 0, 
            chaosMode: false, 
            isInverted: false,
            threshold: 60,
            facingMode: 'environment',
            mainColor: '#FFFFFF',
            bgColor: '#050505',
            isFrozen: false
        };

        let width, height, stream;
        let lastTime = 0;
        let frozenFrame = document.createElement('canvas'); 
        
        const defaultChars = "█▓▒░$@#&%+=WTF01"; 
        const microChars = "10.:"; 

        // Tracker
        let trackers = [];
        const MAX_TRACKERS = 3;

        class Tracker {
            constructor(gx, gy) {
                this.gx = gx; this.gy = gy;
                this.id = "ID-" + Math.floor(Math.random() * 999);
                this.life = 60 + Math.random() * 60; 
                this.active = true;
                this.mass = 1; 
            }
            update(data, cols, rows, brightnessMap) {
                this.life--;
                if (this.life <= 0) this.active = false;
                let sumX = 0, sumY = 0, count = 0;
                const range = 5; 
                for(let dy = -range; dy <= range; dy++) {
                    for(let dx = -range; dx <= range; dx++) {
                        const nx = Math.floor(this.gx + dx);
                        const ny = Math.floor(this.gy + dy);
                        if(nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                            if(brightnessMap[ny * cols + nx] > config.threshold) {
                                sumX += nx; sumY += ny; count++;
                            }
                        }
                    }
                }
                if(count > 0) {
                    this.gx = sumX / count; this.gy = sumY / count; this.mass = count; 
                } else { this.life -= 5; }
            }
            draw(ctx) {
                const screenX = this.gx * config.gridSize;
                const screenY = this.gy * config.gridSize;
                let boxSize = config.gridSize + (this.mass * (config.gridSize * 0.2));
                if(boxSize > config.gridSize * 10) boxSize = config.gridSize * 10;
                
                // Trackers follow color mode
                let stroke = (config.colorMode === 4) ? '#fff' : config.mainColor;
                if(config.isInverted && config.colorMode === 0) stroke = '#000000'; // Black tracker in paper mode
                
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 1;
                
                // Jitter tracker if FX is high
                let jx = 0, jy = 0;
                if (config.fxLevel > 10) {
                    jx = (Math.random() - 0.5) * (config.fxLevel * 0.1);
                    jy = (Math.random() - 0.5) * (config.fxLevel * 0.1);
                }

                ctx.strokeRect(screenX - boxSize/2 + jx, screenY - boxSize/2 + jy, boxSize, boxSize);
                ctx.fillStyle = stroke;
                ctx.font = '10px monospace';
                ctx.fillText(this.id, screenX + boxSize/2 + 2 + jx, screenY - boxSize/2 + jy);
            }
        }

        function updateTheme(color) {
            document.documentElement.style.setProperty('--main', color);
            config.mainColor = color;
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        customTextInput.addEventListener('click', (e) => e.stopPropagation());

        document.addEventListener('click', (e) => {
            if(e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.closest('.controls-top')) return;
            if(startBtn.style.display === 'none') {
                uiContainer.classList.toggle('visible');
            }
        });

        async function initCamera() {
            if (stream) stream.getTracks().forEach(track => track.stop());
            try {
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: config.facingMode, width: { ideal: 1280 }, height: { ideal: 720 } }, 
                    audio: false 
                });
                video.srcObject = stream;
                await video.play();
                document.getElementById('start-screen').style.display = 'none';
                startBtn.style.display = 'none';
                if (!window.isRendering) {
                    window.isRendering = true;
                    requestAnimationFrame(render);
                }
            } catch (err) { alert("ERR: " + err); }
        }

        function render(time) {
            requestAnimationFrame(render);
            const interval = 1000 / config.targetFPS;
            if (time - lastTime < interval) return;
            lastTime = time;

            config.gridSize = parseInt(inputGrid.value);
            config.targetFPS = parseInt(inputFps.value);
            config.fadeAlpha = parseInt(inputFade.value) / 100;
            config.fxLevel = parseInt(inputFx.value); // Corruption level
            
            let useChars = defaultChars;
            const customTxt = customTextInput.value.toUpperCase();
            if(customTxt.length > 0) useChars = customTxt;

            let src = video;
            let vWidth = video.videoWidth;
            let vHeight = video.videoHeight;
            
            if (config.isFrozen) {
                src = frozenFrame;
                vWidth = frozenFrame.width;
                vHeight = frozenFrame.height;
            }

            if (vWidth === 0) return;

            const scale = Math.max(width / vWidth, height / vHeight);
            
            // --- DRAW BACKGROUND ---
            // If Inverted, BG is White, Text is Black.
            // If Normal, BG is Black, Text is Color.
            
            let trailColor = config.isInverted ? `rgba(255, 255, 255, ${config.fadeAlpha})` : `rgba(5, 5, 5, ${config.fadeAlpha})`;
            if (config.fadeAlpha < 0.05) trailColor = config.isInverted ? `rgba(255,255,255,0.05)` : `rgba(5,5,5,0.05)`;
            
            ctx.fillStyle = trailColor;
            ctx.fillRect(0, 0, width, height);

            // --- PROCESSING ---
            const cols = Math.floor(width / config.gridSize);
            const rows = Math.floor(height / config.gridSize);
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = cols;
            tempCanvas.height = rows;

            const gridScale = Math.max(cols / vWidth, rows / vHeight);
            const gridXOff = (cols - (vWidth * gridScale)) / 2;
            const gridYOff = (rows - (vHeight * gridScale)) / 2;

            if (config.facingMode === 'user' && !config.isFrozen) { tempCtx.translate(cols, 0); tempCtx.scale(-1, 1); }
            
            tempCtx.drawImage(src, gridXOff, gridYOff, vWidth * gridScale, vHeight * gridScale);
            const data = tempCtx.getImageData(0, 0, cols, rows).data;

            // Use FX Slider for Contrast boost + Distortion
            // We'll hardcode a base contrast, and use FX slider for Glitch
            const baseContrast = 20;
            const contrastFactor = (259 * (baseContrast + 255)) / (255 * (259 - baseContrast));
            const brightnessMap = new Float32Array(cols * rows);

            ctx.textBaseline = 'top';

            // RENDER LOOP
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const idx = (y * cols + x) * 4;
                    const r = data[idx]; const g = data[idx+1]; const b = data[idx+2];
                    
                    let bright = (r + g + b) / 3;
                    bright = contrastFactor * (bright - 128) + 128;
                    brightnessMap[y * cols + x] = bright;

                    const posX = x * config.gridSize;
                    const posY = y * config.gridSize;

                    // COLOR LOGIC
                    let fillStyle;
                    if (config.isInverted && config.colorMode === 0) {
                        fillStyle = '#000000'; // Black text in Paper Mode
                    } else if (config.colorMode === 4) {
                        fillStyle = `rgb(${Math.random()*255},${Math.random()*255},${Math.random()*255})`;
                    } else if (config.colorMode === 3) {
                        fillStyle = `rgb(${r},${g},${b})`;
                    } else {
                        fillStyle = config.mainColor;
                    }
                    
                    ctx.fillStyle = fillStyle;

                    if (bright > config.threshold) {
                        
                        // --- CORRUPTION / GLITCH LOGIC ---
                        // If FX > 0, we introduce random offsets and color splits
                        let finalX = posX;
                        let finalY = posY;
                        let isGlitching = false;

                        if (config.fxLevel > 0) {
                            const probability = config.fxLevel / 200; // 0 to 0.5 chance
                            if (Math.random() < probability) {
                                isGlitching = true;
                                const shake = (config.fxLevel / 10);
                                finalX += (Math.random() - 0.5) * shake;
                                finalY += (Math.random() - 0.5) * shake;
                                
                                // RGB SPLIT (Chromatic Aberration)
                                if (config.fxLevel > 50) {
                                    // Draw Red Offset
                                    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                                    ctx.fillText("▒", finalX + 2, finalY);
                                    // Draw Blue Offset
                                    ctx.fillStyle = 'rgba(0, 0, 255, 0.7)';
                                    ctx.fillText("▒", finalX - 2, finalY);
                                    // Restore Color
                                    ctx.fillStyle = fillStyle; 
                                }
                            }
                        }

                        // --- CHARACTER SELECTION ---
                        if (config.chaosMode || isGlitching) {
                             const rand = Math.random();
                             if (bright > 180 && rand > 0.96 && x < cols - 1 && y < rows - 1) {
                                ctx.font = `bold ${config.gridSize * 2}px monospace`;
                                const char = (customTxt.length > 0) ? useChars[Math.floor(time/100) % useChars.length] : useChars[Math.floor(Math.random() * useChars.length)];
                                ctx.fillText(char, finalX, finalY);
                            } else if (rand > 0.85 && customTxt.length === 0) { 
                                const subSize = config.gridSize / 2;
                                ctx.font = `${subSize}px monospace`;
                                ctx.fillText(microChars[Math.floor(Math.random()*4)], finalX, finalY);
                                ctx.fillText(microChars[Math.floor(Math.random()*4)], finalX + subSize, finalY);
                                ctx.fillText(microChars[Math.floor(Math.random()*4)], finalX, finalY + subSize);
                                ctx.fillText(microChars[Math.floor(Math.random()*4)], finalX + subSize, finalY + subSize);
                            } else {
                                ctx.font = `${config.gridSize}px monospace`;
                                const char = useChars[Math.floor(Math.random() * useChars.length)];
                                ctx.fillText(char, finalX, finalY);
                            }
                        } else {
                            ctx.font = `${config.gridSize}px monospace`;
                            let char;
                            if (customTxt.length > 0) {
                                const charIdx = (x + y) % useChars.length;
                                char = useChars[charIdx];
                            } else {
                                char = useChars[Math.floor(Math.random() * useChars.length)];
                            }
                            ctx.fillText(char, finalX, finalY);
                        }

                    } else {
                        // Passive Dots
                        if (Math.random() > 0.95) {
                            ctx.fillStyle = config.isInverted ? '#ccc' : '#333';
                            ctx.font = `${config.gridSize}px monospace`;
                            ctx.fillText(".", posX, posY);
                        }
                    }
                }
            }

            // Trackers
            if (trackers.length < MAX_TRACKERS && Math.random() > 0.95 && !config.isFrozen) {
                let attempts = 0;
                while(attempts < 10) {
                    const rx = Math.floor(Math.random() * cols);
                    const ry = Math.floor(Math.random() * rows);
                    if (brightnessMap[ry * cols + rx] > config.threshold) {
                        trackers.push(new Tracker(rx, ry));
                        break;
                    }
                    attempts++;
                }
            }

            for (let i = trackers.length - 1; i >= 0; i--) {
                const t = trackers[i];
                t.update(data, cols, rows, brightnessMap);
                t.draw(ctx);
                if (!t.active) trackers.splice(i, 1);
            }
        }

        freezeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!config.isFrozen) {
                frozenFrame.width = video.videoWidth;
                frozenFrame.height = video.videoHeight;
                const fCtx = frozenFrame.getContext('2d');
                if (config.facingMode === 'user') {
                    fCtx.translate(frozenFrame.width, 0);
                    fCtx.scale(-1, 1);
                }
                fCtx.drawImage(video, 0, 0);
                config.isFrozen = true;
                freezeBtn.innerText = "RUN";
                freezeBtn.style.color = "#ff0000";
            } else {
                config.isFrozen = false;
                freezeBtn.innerText = "FRZ";
                freezeBtn.style.color = config.mainColor;
            }
        });

        snapBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const link = document.createElement('a');
            link.download = `DATA_DECAY_${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            snapBtn.innerText = "SAVED";
            setTimeout(() => snapBtn.innerText = "SNAP", 1000);
        });

        flipBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            config.facingMode = config.facingMode === 'environment' ? 'user' : 'environment';
            config.isFrozen = false;
            freezeBtn.innerText = "FRZ";
            initCamera();
        });

        modeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            config.chaosMode = !config.chaosMode;
            modeBtn.innerText = config.chaosMode ? "MOD: CHAOS" : "MOD: GRID";
        });

        colorBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            config.colorMode++;
            if(config.colorMode > 4) config.colorMode = 0;
            const labels = ["CLR: WHT", "CLR: YLW", "CLR: GRN", "CLR: SRC", "CLR: RND"];
            colorBtn.innerText = labels[config.colorMode];
            if(config.colorMode === 0) updateTheme('#FFFFFF');
            else if(config.colorMode === 1) updateTheme('#eebb00');
            else if(config.colorMode === 2) updateTheme('#00ff41');
            else if(config.colorMode === 3) updateTheme('#FFFFFF'); 
            else if(config.colorMode === 4) updateTheme('#FFFFFF');
            if(!config.isFrozen) freezeBtn.style.color = config.mainColor;
        });

        invBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            config.isInverted = !config.isInverted;
            invBtn.innerText = config.isInverted ? "INV: ON" : "INV: OFF";
            invBtn.classList.toggle('active-state', config.isInverted);
            
            if(config.isInverted) {
                document.body.classList.add('inverted');
                updateTheme('#000000'); // UI becomes black
            } else {
                document.body.classList.remove('inverted');
                // Restore color based on current mode
                if(config.colorMode === 1) updateTheme('#eebb00');
                else if(config.colorMode === 2) updateTheme('#00ff41');
                else updateTheme('#FFFFFF');
            }
        });

        startBtn.addEventListener('click', initCamera);

    </script>
</body>
</html>
